=== Održavanje projekta

(((maintaining a project)))
Sem što treba da znate kako da efikasno doprinesete projektu, verovatno ćete morati da naučite i kako da ga održavate.
Ovo može da se sastoji od prihvatanja i primenjivanja zakrpa generisane sa `format-patch` i poslate vama putem mejla, ili od integrisanja promena na udaljenim granama za repozitorijume koje ste dodali kao rimoutove svom projektu.
Bilo da održavate kanoničan repozitorijum ili želite da pomognete tako što ćete verifikovati ili prihvatati zakrpe, treba da znate kako da prihvatite rad na način koji je najpregledniji drugim kontributorima i da možete da ga održavate na duge staze.

==== Rad sa tematskim granama

(((branches, topic)))
Kada razmišljate o integrisanje novog rada, u opštem slučaju je dobra ideja da stvari prvo isprobate na tematskoj grani -- na trenutnoj grani koju ste napravili specifično radi testiranja da li novi delovi koda rade.
Na ovaj način je lako uneti male izmene posebno u zakrpu i ostaviti je tako ako ne radi dok ne budete imali vremena da se kasnije posvetite njoj.
Održavalac Git projekta neretko pravi i nejmspejs za grane -- na primer `sc/ruby_client`, gde je `sc` skraženica za osobu koja doprinosi radu.
Kao što se sećate, možete da napravite grane bazirane na `master` grani na sledeći način:

[source,console]
-----
$ git branch sc/ruby_client master
-----

Ili, ako želite da odmah i skočite na nju, možete da iskoristite `checkout -b` opciju:

[source,console]
-----
$ git checkout -b sc/ruby_client master
-----

Sada ste spremni da dodate svoj doprinos ovoj tematskoj grani i da odlučite da li želite da je spojite u odgovarajuću dugotrajnu granu.

[[_patches_from_email]]
==== Primenjivanje zakrpa preko mejlova

(((email, applying patches from)))
Ako dobijete zakrpu preko mejla i treba da je integrišete u svoj projekat, treba da primenite zakrpu na tematsku granu i da je procenite.
Postoje dva načina za primenjivanje zakrpe koju ste dobiji butem mejla: pomoću `git apply` ili `git am`.

===== Primenjivanje zakrpe sa `apply`

(((git commands, apply)))
Ako ste dobili zakrpu od nekog ko ju je generisao sa `git diff` ili Juniksovom `diff` komandom (što nije preporučljivo, pogledajte sledeći odeljak), možete da je primenite `git apply` komandom.
Pod pretpostavkom da ste sačuvati zakrpu na `/tmp/patch-ruby-client.patch`, možete da je primenite ovako:

[source,console]
-----
$ git apply /tmp/patch-ruby-client.patch
-----

Ovo modifikuje fajlove u radnom direktorijumu.
OVo je skoro identično kao i pokretanje `patch -p1` komande za prihvatanje zakrpe, mada je više paranoična i prihvata manje nejasnijih parova nego `patch`.
Rukuje i dodavanjem, brisanjem i preimenovanjem fajlova ako su opisani u `git diff` formatu, što `patch` neće da uradi.
Konačno, `git apply` je model sa principom "primeni sve ili odbaci sve" gde će se ili primeniti sve ili ništa, dok `patch` može parcijalno da primenjuje zakrpe, ostavljajući radni direktorijum u čudnom stanju.
`git apply` je i generalno mnogo konzervativniji nego `patch`.
Neće kreirati komit umesto vas -- kada ga pokrenete, morate da stejdžujete komit i ručno komitujete novonastale promene.

Možete da koristite `git apply` i da vidite da li će se zakrpa uklopiti kako valja pre nego što zapravo probate da je primenite -- samo pokrenite `git apply --check` sa zakrpom:

[source,console]
-----
$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
-----

Ako nema izlaza, to znači da će se zakrpa prihvatiti kako valja.
Ova komanda takođe daje ne-nula izlaz u slučaju neuspeha, tako da možete da je koristite u skriptama ako želite.

[[_git_am]]
===== Primenjivanje zakrpe sa `am`

(((git commands, am)))
Ako je kontributor korisnik Gita i ako je bio dovoljno dobar da iskoristi `format-patch` komandu da generiše svoju zakrpu, onda će vaš posao mnogo lakši jer zakrpa sadrži informacije o autoru i komit poruke.
Ako možete, ohrabrujte svoje kontributore da korsite `format-patch` umesto `diff` za generisanje zakrpa koje vam šalju.
Treba da morate da koristite `git apply` samo za legat zakrpe i takve stvari.

Da biste primenili zakrpu koja je generisana sa `format-patch`, koristite `git am`..
Tehnički, `git am` je stvoren da čita `mbox` fajlove; to su jednostavni fajlovi običnog tekstualnog formata koji služe za čuvanje jedne ili više mejl poruka u jednom tekstualnom fajlu.
Izgledaju nekako ovako:

[source,console]
-----
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20
-----
Ovo je početak izlaza komande `format-patch` koju ste upravo videli u prethodnom odeljku.
Ovo je takođe validan `mbox` mejl format.
Ako vam neko poslao mejl sa zakrpom koristeći `git send-email`, a vi skinete to u `mbox` format, onda možete da usmerite `git am` na taj `mbox` fajl, i počeće da primenjuje sve zakrpe koje vidi.
Ako pokrenete mejl klijent koji može da čuva nekoliko mejlova u `mbox` formatu, možete da sačuvate čitavu seriju zakrpi u fajl i onda da iskoristite `git am` da ih primenjujete jednu po jednu.

Međutim, ako je neko okačio zakrpu koju je generisao sa `format-patch` na sistem za tikete ili nešto slično, možete da sačuvate fajl lokalno i onda da prosledite taj fajl koji je sačuvan na disku komandi `git am` da biste je primenili:

[source,console]
-----
$ git am 0001-limit-log-function.patch
Applying: add limit to log function
-----

Kao što vidite, zakrpa je primenjena bez problema i automatski je kreiran novi komit.
Informacije o autoru su uzete iz `Form` i `Date` hedera sa mejla, a poruka komita je iz `Subject`-a i tela (pre zakrpe) mejla.
Na primer, ako je ova zakrpa primenjena sa `mbox` primera odozgo, generisani komit bi izgledao nekako ovako:

-----
$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith <jessica@example.com>
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon <schacon@gmail.com>
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20
-----

Informacija `Commit` ukazuje na osobu koja je primenila zakrpu i na vreme kada je to učinjeno.
Informacija `Author` je osoba koja je prvobitno napravila zakrpu i to vreme.

Ali moguće je i da se zakrpa ne primeni bez problema.
Možda je glavna grana divergirala predaleko od grane za koju je zakrpa napravljena, ili zakrpa zavisi od druge zakrpe koju još uvek niste primenili.
U tom slučaju, `git am` proces neće uspeti i pitaće vas šta želite da uradite:

[source,console]
-----
$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".
-----

Ova komanda stavlja konfliktne markere u svim fajlovima sa kojima ima problema, slično kao kod konflikta pri spajanju ili rebaziranja.
Problem se takošđe rešava na isti način -- editovanjem fajla da bi se rešio konflikt; zatim se stejdžuje novi fajl, i onda se pokrene `git am --resolved` da bi se krenulo na sledeću zakrpu:

[source,console]
-----
$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
-----

Ako želite da Git proba da malo inteligentnije reši konflikt, možete da mu prosledite opciju `-3`, što tera Git da proba trostruki spoj.
Ova opcija uključena po podrazumevanim podešavanjima jer ne radi ako vam komit na kome zakrpa kaže da je bazirana nije u repozitorijumu.
Ako imate taj komit -- ako je grana bazirana na javnom komitu -- onda je opcija `-3` generalno mnogo pametnija o primenjivanju zakrpe sa konfliktom:

[source,console]
-----
$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
-----

U ovom slučaju, ova zakrpa je već primenjena.
Bez opcie `-3`, izgleda kao konflikt.

Ako primenjujete nekoliko zakrpa iz `mbox`-a, možete i da pokrenete `am` komandu u interaktivnom modu, koja staje na svakoj zakrpi koju pronađe i pita vas da li biste želeli da je primenite.

[source,console]
-----
$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
-----

Ovo je lepo ako imate sačuvan poveći broj zakrpa, jer možete da vidite zakrpu prvo ako se ne sećate šta je u pitanju, ili da ne primenite zakrpu ako ste to već uradili.

Kada su sve zakrpe za vašu temu primenjene i komitovane na vašu granu, možete da izaberete da li ćete i kako da ih integrišete u dugotrajniju granu.

[[_checking_out_remotes]]
==== Čekautovanje udaljenih grana

(((branches, remote)))
Ako je doprinos došao od Git korisnika koji je podesio sopstven repozitorijum, gurnuo neki broj promena na njega, i onda vam poslao URL do repozitorijuma i ime udaljene grane na kojoj se nalaze promene, možete da ih dodate kao rimout i da uradite spojete lokalno.

Recimo, ako je vam je Milica poslala mejl u kome kaže da ima odličnu novu stvar u `ruby-client` grani svog repozitorijuma, možete da je testirate dodavanjem rimouta i čekautovanjem te grane lokalno:
For instance, if Jessica sends you an email saying that she has a great new feature in the `ruby-client` branch of her repository, you can test it by adding the remote and checking out that branch locally:

[source,console]
-----
$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
-----

Ako vam pošalje još jedan mejl kasnije i kaže vam da postoji još jedna grana sa korisnim stvarima, možete da ih pribavite i čekautujete jer već imate podešvanja za rimout.

Ovo je najkorisnije ako radite sa osobom konzistentno.
Ako neko ima samo jednu zakrpu kojom doprinosi s vremena na vreme, onda je prihvatanje preko mejla brže nego zahtevanje da svi imaju svoj server i da svi kontinualno dodaju i brišu rimoutove da bi dobili nove zakrpe.
Takođe, malo je verovatno da želite da imate na stotine rimoutova, svaki za nekog ko doprinese samo jednom ili dvaput.
Ipak, skripte i hostovani servisi mogu ovo da učine jednostavnijim -- zavisi najviše od toga kako razvijate program i kako vaši saradnici kodiraju.

Druga prednost ovog pristupa je to što dobijate i istoriju komitova.
Mada možete da imate ozbiljne probleme sa spajanjem, znate gde je u istoriji baziran njihov rad; ispravan trostruki spoj je podrazumevani tako da ne morate da ubacujete `-3` i da se nadate da je zakrpa generisana za javni komit kome imate pristup.

Ako ne radite sa osobom konzistentno, ali ipak želite da povučete sa njih na ovaj način, možete da navedete URL udaljenog repozitorijuma `git pull` komandi.
Ovo radi jednovremeno povlačenje i ne čuva URL kao udaljenu referencu:

[source,console]
-----
$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -> FETCH_HEAD
Merge made by recursive.
-----

[[_what_is_introduced]]
==== Kako utvrditi šta je uvedeno

(((branches, diffing)))
Sada imate tematsku granu koja sadrži doprinesen rad.
U ovom trenutku možete da odlučite šta ćete da radite sa njim.
Ovaj odeljak se ponovo osvrće na nekoliko komandi kako biste videli kako da ih iskoristite da biste videli tačno šta ćete uraditi ako spojite ovo u glavnu granu.

Često je korisno da pogledate izvrštaj svih komitova koji su u ovoj grani ali nisu na `master` grani.
Možete da izbacite komitove sa `master` grane tako što ćete dodati `--not` ispred imena grane.
Ovo radi istu stvar kao i `master..contrib` format koji smo koristili ranije.
Na primer, ako vam kontributor pošalje dve zakrep i napravite granu koja se zove `contrib` i primenite te zakrpe tamo, možete da pokrenete ovo:

[source,console]
-----
$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon <schacon@gmail.com>
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better
-----

Da biste videli koje promene svaki od komitova uvodi, setite se da možete da prosledite `-p` opciju komandi `git log` i onda ćete moći da vidite razliku koja je uvedena pri svakom komitu.

Da biste videli punu razliku onoga što bi se dogodilo ako biste spojili ovu tematsku granu sa drugom granom, možda ćete morati da upotrebite čudan trik da biste dobili ispravne rezultat.
Razmislite o pokretanju ove komande:

[source,console]
-----
$ git diff master
-----

Ova komanda vam daje razliku, ali može da vas zavara.
Ako se vaša `master` grana kretala napred od kada ste napravili tematsku granu od nje, onda ćete naizgled dobiti čudne rezultate.
Ovo se dešava jer Git direktno poredi snimke poslednjeg komita sa tematske grane na kojo ste sada i poslednjeg komita `master` grane.
Na primer, ako ste dodali liniju u fajlu na `master` grani, direktno poređenje snimaka će izgledati kao da će tematska grana da obriše tu liniju.

Ako je `master` direktan predak tematske grane, ovo nije problem; ali ako su dve istorije divergirale, razlika će izgledati kao da dodajete sve noe stvari u tematsku granu i brišete sve jedinstveno `master` grani.

Ono što stvarno hoćete da vidite su promene koje su dodate na tematskoj grani -- rad koji ćete uvesti ako spojite ovu granu sa `master`-om.
To ćete uraditi tako što ćete reči Gitu da uporedi poslednji komit sa tematske gran sa prvim zajedničkim pretkom koji ima sa master granom.

Tehnički, to možete da uradite tako što ćete eksplicitno naći zajedničkog pretka i onda pokrenuti `diff` nad time:

[source,console]
-----
$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db
-----

Međutim, ovo nije zgodno za rad, pa Git nudi još jednu skraćenicu kojom radite istu stvar: sintaksu sa tri tačke.
U kopntekstu `diff` komande, možete da stavite tri tačke posle druge grane da biste uradili `diff` između poslednjeg komita grane na koje se nalazite i njegovog zajedničkog pretka sa drugom granom:

[source,console]
-----
$ git diff master...contrib
-----

Ova komanda vam prikazuje samo rad koji koji je trenutna tematska grana uvela od zajedničkog pretka sa `master`-om.
To je veoma korisna sintaksa koju treba upamtiti.

==== Integrisanje doprinesenog rada

(((integrating work)))
KAda je sav rad na tematskoj grani spreman za integrisanje u glavniju granu, postavlja se pitanje kako izvesti to.
Sem toga, koji sveobuhvatni tok rada želite da koristite na svom projektu?
Imate puno izbora, pa ćemo pokriti nekoliko njih.

===== Tokovi rada sa spajanjem

(((workflows, merging)))
Jdan jednostavan tok rada spaja vaš rad sa `master` granom.
U oovom scenariju, imate `master` granu koja u suštini sadrži stabilan kod.
Kada morate da radite sa tematskim granama koje ste vi napravili ili koje su plod nečijeg doprinosa a vi ste ih potvrdili, spajate ih u svoju `master` granu, prišete tematsku granu i onda nastavljate proces.
Ako imamo repozitorijum sa radom u dve grane koje se zovu `ruby_client` i `php_client` koji izgleda kao <<merwf_a>> i spojimo `ruby_client` prvo pa onda `php_client`, istorija koju ćete na kraju imati izgleda kao <<merwf_b>>.

[[merwf_a]]
.Istorija sa nekoliko tematskih grana.
image::images/merging-workflows-1.png[Istorija sa nekoliko tematskih grana.]

[[merwf_b]]
.Posle spajanja tematske grane.
image::images/merging-workflows-2.png[Posle spajanja tematske grane.]

Ovo je verovatno najjednostavniji tok rada, ali može da bude problematičan ako radite na većim ili stabilnijim projektima gde želite da bude jako obazrivi oko toga šta uvodite u izmene.

Ako imate važniji projekat, možda ćete želeti da koristite dvofazni cilkus spoja.
U voom scenariju, imate dve dugotrajne grane, `master` i `develop`, u kojima odlučujete da se `master` apdejtuje samo kada nastane veoma stabla situacija a sav novi kod se integriše u `develop` granu.
Regularno gurate obe ove grane u javni repozitorijum.
Svaki put kada imate novu tematsku granu kou treba spojiti (<<merwf_c>>), spajate je u `develop` (<<merwf_d>>); onda, kada tagujete izdanje, premotate `master` na koje god mesto da se nalazi sada stablna `develop` grana (<<merwf__e>>).

[[merwf_c]]
.Before a topic branch merge.
image::images/merging-workflows-3.png[Before a topic branch merge.]

[[merwf_d]]
.After a topic branch merge.
image::images/merging-workflows-4.png[After a topic branch merge.]

[[merwf_e]]
.After a project release.
image::images/merging-workflows-5.png[After a topic branch release.]

Ovako, kada ljudi kloniraju repozitorijum vašeg projekta, mogu ili da čekautuje `master` da bi izbildovali najstabliniju verziju i lako uvek imaju aktuelnu verziju, ili mogu da čekautuje `develop`, što je napredniji ali slabije testiran kod.
Možete i da nastavite ovaj koncept, da imate `integrate` granu gde se sav rad spaja u jedno.
Onda, kada kôd na toj grani postane stabila i prođe testiranje, spajate ga na `develop` granu; i kada se to pokaže kao stabilno neko vreme, premotate `master` granu unapred.

===== Large-Merging Workflows

(((workflows, "merging (large)")))
The Git project has four long-running branches: `master`, `next`, and `pu` (proposed updates) for new work, and `maint` for maintenance backports.
When new work is introduced by contributors, it's collected into topic branches in the maintainer's repository in a manner similar to what we've described (see <<merwf_f>>).
At this point, the topics are evaluated to determine whether they're safe and ready for consumption or whether they need more work.
If they're safe, they're merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.

[[merwf_f]]
.Managing a complex series of parallel contributed topic branches.
image::images/large-merges-1.png[Managing a complex series of parallel contributed topic branches.]

If the topics still need work, they're merged into `pu` instead.
When it's determined that they're totally stable, the topics are re-merged into `master` and are then rebuilt from the topics that were in `next` but didn't yet graduate to `master`.
This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often:

.Merging contributed topic branches into long-term integration branches.
image::images/large-merges-2.png[Merging contributed topic branches into long-term integration branches.]

When a topic branch has finally been merged into `master`, it's removed from the repository.
The Git project also has a `maint` branch that is forked off from the last release to provide backported patches in case a maintenance release is required.
Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.

[[_rebase_cherry_pick]]
===== Rebasing and Cherry Picking Workflows

(((workflows, rebasing and cherry-picking)))
Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history.
When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or `develop`, and so on) branch.
If that works well, you can fast-forward your `master` branch, and you'll end up with a linear project history.

(((git commands, cherry-pick)))
The other way to move introduced work from one branch to another is to cherry-pick it.
A cherry-pick in Git is like a rebase for a single commit.
It takes the patch that was introduced in a commit and tries to reapply it on the branch you're currently on.
This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you'd prefer to cherry-pick it rather than run rebase.
For example, suppose you have a project that looks like this:

.Example history before a cherry-pick.
image::images/rebasing-1.png[Example history before a cherry-pick.]

If you want to pull commit `e43a6` into your master branch, you can run

[source,console]
-----
$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
-----

This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different.
Now your history looks like this:

.History after cherry-picking a commit on a topic branch.
image::images/rebasing-2.png[History after cherry-picking a commit on a topic branch.]

Now you can remove your topic branch and drop the commits you didn't want to pull in.

===== Rerere

(((git commands, rerere)))(((rerere)))
If you're doing lots of merging and rebasing, or you're maintaining a long-lived topic branch, Git has a feature called ``rerere'' that can help.

Rerere stands for ``reuse recorded resolution'' – it's a way of shortcutting manual conflict resolution.
When rerere is enabled, Git will keep a set of pre- and post-images from successful merges, and if it notices that there's a conflict that looks exactly like one you've already fixed, it'll just use the fix from last time, without bothering you with it.

This feature comes in two parts: a configuration setting and a command.
The configuration setting is `rerere.enabled`, and it's handy enough to put in your global config:

[source,console]
----
$ git config --global rerere.enabled true
----

Now, whenever you do a merge that resolves conflicts, the resolution will be recorded in the cache in case you need it in the future.

If you need to, you can interact with the rerere cache using the `git rerere` command.
When it's invoked alone, Git checks its database of resolutions and tries to find a match with any current merge conflicts and resolve them (although this is done automatically if `rerere.enabled` is set to `true`).
There are also subcommands to see what will be recorded, to erase specific resolution from the cache, and to clear the entire cache.
We will cover rerere in more detail in <<_rerere>>.

[[_tagging_releases]]
==== Tagging Your Releases

(((tags)))(((tags, signing)))
When you've decided to cut a release, you'll probably want to drop a tag so you can re-create that release at any point going forward.
You can create a new tag as discussed in <<_git_basics_chapter>>.
If you decide to sign the tag as the maintainer, the tagging may look something like this:

[source,console]
-----
$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon <schacon@gmail.com>"
1024-bit DSA key, ID F721C45A, created 2009-02-09
-----

If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags.
The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content.
To do this, you can figure out which key you want by running `gpg --list-keys`:

[source,console]
-----
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon <schacon@gmail.com>
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
-----

Then, you can directly import the key into the Git database by exporting it and piping that through `git hash-object`, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:

[source,console]
-----
$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the `hash-object` command gave you:

[source,console]
-----
$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared with everyone.
If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:

[source,console]
-----
$ git show maintainer-pgp-pub | gpg --import
-----

They can use that key to verify all your signed tags.
Also, if you include instructions in the tag message, running `git show <tag>` will let you give the end user more specific instructions about tag verification.

[[_build_number]]
==== Generating a Build Number

(((build numbers)))(((git commands, describe)))
Because Git doesn't have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.
Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you're describing:

[source,console]
-----
$ git describe master
v1.6.2-rc1-20-g8c5b85c
-----

This way, you can export a snapshot or build and name it something understandable to people.
In fact, if you build Git from source code cloned from the Git repository, `git --version` gives you something that looks like this.
If you're describing a commit that you have directly tagged, it gives you the tag name.

The `git describe` command favors annotated tags (tags created with the `-a` or `-s` flag), so release tags should be created this way if you're using `git describe`, to ensure the commit is named properly when described.
You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older `git describe` output names were invalidated.

[[_preparing_release]]
==== Preparing a Release

(((releasing)))(((git commands, archive)))
Now you want to release a build.
One of the things you'll want to do is create an archive of the latest snapshot of your code for those poor souls who don't use Git.
The command to do this is `git archive`:

[source,console]
-----
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz
-----

If someone opens that tarball, they get the latest snapshot of your project under a project directory.
You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`:

[source,console]
-----
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
-----

You now have a nice tarball and a zip archive of your project release that you can upload to your website or email to people.

[[_the_shortlog]]
==== The Shortlog

(((git commands, shortlog)))
It's time to email your mailing list of people who want to know what's happening in your project.
A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or email is to use the `git shortlog` command.
It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:

[source,console]
-----
$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2
-----

You get a clean summary of all the commits since v1.0.1, grouped by author, that you can email to your list.
